//*
// CAN service.
//
// Service that enables a control of the CAN features of device

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: CanService.proto

package protos

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Can_GetTransceiverPower_FullMethodName            = "/hal.can.Can/GetTransceiverPower"
	Can_GetTermination_FullMethodName                 = "/hal.can.Can/GetTermination"
	Can_SetTransceiverPower_FullMethodName            = "/hal.can.Can/SetTransceiverPower"
	Can_SetTermination_FullMethodName                 = "/hal.can.Can/SetTermination"
	Can_ListInterfaces_FullMethodName                 = "/hal.can.Can/ListInterfaces"
	Can_GetStatistics_FullMethodName                  = "/hal.can.Can/GetStatistics"
	Can_GetBitrate_FullMethodName                     = "/hal.can.Can/GetBitrate"
	Can_GetBusState_FullMethodName                    = "/hal.can.Can/GetBusState"
	Can_SetInterfaceToContainer_FullMethodName        = "/hal.can.Can/SetInterfaceToContainer"
	Can_GetInterfaceToContainerMapping_FullMethodName = "/hal.can.Can/GetInterfaceToContainerMapping"
)

// CanClient is the client API for Can service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// *
// Service exposing CAN functions.
type CanClient interface {
	// Gets the state of transceiver power
	GetTransceiverPower(ctx context.Context, in *GetInterfaceNameRequest, opts ...grpc.CallOption) (*GetTransceiverPowerResponse, error)
	// Gets the state of termination
	GetTermination(ctx context.Context, in *GetInterfaceNameRequest, opts ...grpc.CallOption) (*GetTerminationResponse, error)
	// Sets the transceiver power (on/off)
	SetTransceiverPower(ctx context.Context, in *SetTransceiverPowerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Enables or disables CAN termination
	SetTermination(ctx context.Context, in *SetTerminationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Lists available CAN interfaces
	ListInterfaces(ctx context.Context, in *ListInterfacesRequest, opts ...grpc.CallOption) (*ListInterfacesResponse, error)
	// Gets the CAN interface statistics
	GetStatistics(ctx context.Context, in *GetInterfaceNameRequest, opts ...grpc.CallOption) (*GetStatisticsResponse, error)
	// Gets the CAN interface bitrate
	GetBitrate(ctx context.Context, in *GetInterfaceNameRequest, opts ...grpc.CallOption) (*GetBitrateResponse, error)
	// Gets the CAN interface state
	GetBusState(ctx context.Context, in *GetInterfaceNameRequest, opts ...grpc.CallOption) (*GetBusStateResponse, error)
	// Moves specified interface into namespace of a specified docker container
	SetInterfaceToContainer(ctx context.Context, in *SetInterfaceToContainerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Returns mapping of interfaces onto docker containers
	GetInterfaceToContainerMapping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetInterfaceToContainerMappingResponse, error)
}

type canClient struct {
	cc grpc.ClientConnInterface
}

func NewCanClient(cc grpc.ClientConnInterface) CanClient {
	return &canClient{cc}
}

func (c *canClient) GetTransceiverPower(ctx context.Context, in *GetInterfaceNameRequest, opts ...grpc.CallOption) (*GetTransceiverPowerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTransceiverPowerResponse)
	err := c.cc.Invoke(ctx, Can_GetTransceiverPower_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canClient) GetTermination(ctx context.Context, in *GetInterfaceNameRequest, opts ...grpc.CallOption) (*GetTerminationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTerminationResponse)
	err := c.cc.Invoke(ctx, Can_GetTermination_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canClient) SetTransceiverPower(ctx context.Context, in *SetTransceiverPowerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Can_SetTransceiverPower_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canClient) SetTermination(ctx context.Context, in *SetTerminationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Can_SetTermination_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canClient) ListInterfaces(ctx context.Context, in *ListInterfacesRequest, opts ...grpc.CallOption) (*ListInterfacesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListInterfacesResponse)
	err := c.cc.Invoke(ctx, Can_ListInterfaces_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canClient) GetStatistics(ctx context.Context, in *GetInterfaceNameRequest, opts ...grpc.CallOption) (*GetStatisticsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStatisticsResponse)
	err := c.cc.Invoke(ctx, Can_GetStatistics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canClient) GetBitrate(ctx context.Context, in *GetInterfaceNameRequest, opts ...grpc.CallOption) (*GetBitrateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBitrateResponse)
	err := c.cc.Invoke(ctx, Can_GetBitrate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canClient) GetBusState(ctx context.Context, in *GetInterfaceNameRequest, opts ...grpc.CallOption) (*GetBusStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBusStateResponse)
	err := c.cc.Invoke(ctx, Can_GetBusState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canClient) SetInterfaceToContainer(ctx context.Context, in *SetInterfaceToContainerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Can_SetInterfaceToContainer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canClient) GetInterfaceToContainerMapping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetInterfaceToContainerMappingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetInterfaceToContainerMappingResponse)
	err := c.cc.Invoke(ctx, Can_GetInterfaceToContainerMapping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CanServer is the server API for Can service.
// All implementations must embed UnimplementedCanServer
// for forward compatibility.
//
// *
// Service exposing CAN functions.
type CanServer interface {
	// Gets the state of transceiver power
	GetTransceiverPower(context.Context, *GetInterfaceNameRequest) (*GetTransceiverPowerResponse, error)
	// Gets the state of termination
	GetTermination(context.Context, *GetInterfaceNameRequest) (*GetTerminationResponse, error)
	// Sets the transceiver power (on/off)
	SetTransceiverPower(context.Context, *SetTransceiverPowerRequest) (*emptypb.Empty, error)
	// Enables or disables CAN termination
	SetTermination(context.Context, *SetTerminationRequest) (*emptypb.Empty, error)
	// Lists available CAN interfaces
	ListInterfaces(context.Context, *ListInterfacesRequest) (*ListInterfacesResponse, error)
	// Gets the CAN interface statistics
	GetStatistics(context.Context, *GetInterfaceNameRequest) (*GetStatisticsResponse, error)
	// Gets the CAN interface bitrate
	GetBitrate(context.Context, *GetInterfaceNameRequest) (*GetBitrateResponse, error)
	// Gets the CAN interface state
	GetBusState(context.Context, *GetInterfaceNameRequest) (*GetBusStateResponse, error)
	// Moves specified interface into namespace of a specified docker container
	SetInterfaceToContainer(context.Context, *SetInterfaceToContainerRequest) (*emptypb.Empty, error)
	// Returns mapping of interfaces onto docker containers
	GetInterfaceToContainerMapping(context.Context, *emptypb.Empty) (*GetInterfaceToContainerMappingResponse, error)
	mustEmbedUnimplementedCanServer()
}

// UnimplementedCanServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCanServer struct{}

func (UnimplementedCanServer) GetTransceiverPower(context.Context, *GetInterfaceNameRequest) (*GetTransceiverPowerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransceiverPower not implemented")
}
func (UnimplementedCanServer) GetTermination(context.Context, *GetInterfaceNameRequest) (*GetTerminationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTermination not implemented")
}
func (UnimplementedCanServer) SetTransceiverPower(context.Context, *SetTransceiverPowerRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTransceiverPower not implemented")
}
func (UnimplementedCanServer) SetTermination(context.Context, *SetTerminationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTermination not implemented")
}
func (UnimplementedCanServer) ListInterfaces(context.Context, *ListInterfacesRequest) (*ListInterfacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListInterfaces not implemented")
}
func (UnimplementedCanServer) GetStatistics(context.Context, *GetInterfaceNameRequest) (*GetStatisticsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatistics not implemented")
}
func (UnimplementedCanServer) GetBitrate(context.Context, *GetInterfaceNameRequest) (*GetBitrateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBitrate not implemented")
}
func (UnimplementedCanServer) GetBusState(context.Context, *GetInterfaceNameRequest) (*GetBusStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBusState not implemented")
}
func (UnimplementedCanServer) SetInterfaceToContainer(context.Context, *SetInterfaceToContainerRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetInterfaceToContainer not implemented")
}
func (UnimplementedCanServer) GetInterfaceToContainerMapping(context.Context, *emptypb.Empty) (*GetInterfaceToContainerMappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInterfaceToContainerMapping not implemented")
}
func (UnimplementedCanServer) mustEmbedUnimplementedCanServer() {}
func (UnimplementedCanServer) testEmbeddedByValue()             {}

// UnsafeCanServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CanServer will
// result in compilation errors.
type UnsafeCanServer interface {
	mustEmbedUnimplementedCanServer()
}

func RegisterCanServer(s grpc.ServiceRegistrar, srv CanServer) {
	// If the following call pancis, it indicates UnimplementedCanServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Can_ServiceDesc, srv)
}

func _Can_GetTransceiverPower_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInterfaceNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanServer).GetTransceiverPower(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Can_GetTransceiverPower_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanServer).GetTransceiverPower(ctx, req.(*GetInterfaceNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Can_GetTermination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInterfaceNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanServer).GetTermination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Can_GetTermination_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanServer).GetTermination(ctx, req.(*GetInterfaceNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Can_SetTransceiverPower_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTransceiverPowerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanServer).SetTransceiverPower(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Can_SetTransceiverPower_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanServer).SetTransceiverPower(ctx, req.(*SetTransceiverPowerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Can_SetTermination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTerminationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanServer).SetTermination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Can_SetTermination_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanServer).SetTermination(ctx, req.(*SetTerminationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Can_ListInterfaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInterfacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanServer).ListInterfaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Can_ListInterfaces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanServer).ListInterfaces(ctx, req.(*ListInterfacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Can_GetStatistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInterfaceNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanServer).GetStatistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Can_GetStatistics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanServer).GetStatistics(ctx, req.(*GetInterfaceNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Can_GetBitrate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInterfaceNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanServer).GetBitrate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Can_GetBitrate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanServer).GetBitrate(ctx, req.(*GetInterfaceNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Can_GetBusState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInterfaceNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanServer).GetBusState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Can_GetBusState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanServer).GetBusState(ctx, req.(*GetInterfaceNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Can_SetInterfaceToContainer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetInterfaceToContainerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanServer).SetInterfaceToContainer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Can_SetInterfaceToContainer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanServer).SetInterfaceToContainer(ctx, req.(*SetInterfaceToContainerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Can_GetInterfaceToContainerMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanServer).GetInterfaceToContainerMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Can_GetInterfaceToContainerMapping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanServer).GetInterfaceToContainerMapping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Can_ServiceDesc is the grpc.ServiceDesc for Can service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Can_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hal.can.Can",
	HandlerType: (*CanServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTransceiverPower",
			Handler:    _Can_GetTransceiverPower_Handler,
		},
		{
			MethodName: "GetTermination",
			Handler:    _Can_GetTermination_Handler,
		},
		{
			MethodName: "SetTransceiverPower",
			Handler:    _Can_SetTransceiverPower_Handler,
		},
		{
			MethodName: "SetTermination",
			Handler:    _Can_SetTermination_Handler,
		},
		{
			MethodName: "ListInterfaces",
			Handler:    _Can_ListInterfaces_Handler,
		},
		{
			MethodName: "GetStatistics",
			Handler:    _Can_GetStatistics_Handler,
		},
		{
			MethodName: "GetBitrate",
			Handler:    _Can_GetBitrate_Handler,
		},
		{
			MethodName: "GetBusState",
			Handler:    _Can_GetBusState_Handler,
		},
		{
			MethodName: "SetInterfaceToContainer",
			Handler:    _Can_SetInterfaceToContainer_Handler,
		},
		{
			MethodName: "GetInterfaceToContainerMapping",
			Handler:    _Can_GetInterfaceToContainerMapping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "CanService.proto",
}
